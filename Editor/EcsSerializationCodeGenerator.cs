namespace Game.Ecs.Network.Editor
{
    using System;
    using System.Text;
    using NetworkCommands.Data;
    using Shared.Data;
    using UniModules.Editor;
    using UnityCodeGen;
    using UnityEditor;
    using UnityEngine;

    [Generator] // Add GeneratorAttribute
    public class EcsSerializationCodeGenerator : ICodeGenerator // Inherits ICodeGenerator
    {
        
        public const string OutputPath = "Assets/UniGame.Generated/EcsSerialization";
        public const string FileName = "EcsNetworkSerializers.Generated.cs";
        public const string ContentKey = "%CONTENT%";
        public const string NamespaceKey = "%NAMESPACE%";
        public const string NamespaceTemplate = "\tusing {0};";
        public const string NamespaceContentTemplate = "%NAMESPACE_TEMPLATE%";
        public const string TemplateNamespaceStart = "//====NAMESPACE_START====//";
        public const string TemplateNamespaceEND = "//====NAMESPACE_END====//";
        public const string TemplateClassStart = "//====TEMPLATE_START====//";
        public const string TemplateClassEnd = "//====TEMPLATE_END====//";
        public const string RootTemplate = 
@"//<auto-generated/>
namespace UniGame.Generated.EcsSerialization
{

%NAMESPACE_TEMPLATE%
%NAMESPACE%

%CONTENT%

}";
        
        public void Execute(GeneratorContext context)
        {
            context.OverrideFolderPath(OutputPath);

            var templateAsset = AssetEditorTools
                .GetAsset<TextAsset>(nameof(TemplateEcsTypeSerializer),Array.Empty<string>());
            
            var template = templateAsset.text;
            var startTemplate = template.IndexOf(TemplateClassStart,StringComparison.OrdinalIgnoreCase);
            var endTemplate = template.IndexOf(TemplateClassEnd,StringComparison.OrdinalIgnoreCase);
            startTemplate += TemplateClassStart.Length;

            var classTemplate = template.Substring(startTemplate, endTemplate - startTemplate);
            
            var namespaceStart = template.IndexOf(TemplateNamespaceStart, StringComparison.OrdinalIgnoreCase);
            var namespaceEnd = template.IndexOf(TemplateNamespaceEND, StringComparison.OrdinalIgnoreCase);
            var namespaceTemplate = template.Substring(namespaceStart, namespaceEnd - namespaceStart);
            
            var stringBuilder = new StringBuilder();
            var namespaceBuilder = new StringBuilder();
            var networkTypes = TypeCache.GetTypesDerivedFrom<IEcsNetworkValue>();
            
            foreach (var networkType in networkTypes)
            {
                if(networkType.IsAbstract || networkType.IsInterface) continue;
                
                var targetType = networkType;
                var typeName = targetType.Name;
                var classValue = classTemplate.Replace(nameof(TemplateSerializeType), typeName);
                classValue = classValue.Replace(nameof(TemplateEcsTypeSerializer), $"{typeName}TypeSerializer");
                namespaceBuilder.AppendLine(string.Format(NamespaceTemplate, targetType.Namespace));
                stringBuilder.AppendLine(classValue);
            }

            var resultTemplate = RootTemplate;
            resultTemplate = resultTemplate.Replace(NamespaceContentTemplate, namespaceTemplate);
            resultTemplate = resultTemplate.Replace(NamespaceKey, namespaceBuilder.ToString());
            resultTemplate = resultTemplate.Replace(ContentKey, stringBuilder.ToString());
            
            context.AddCode(FileName, resultTemplate);

            foreach (var networkAsset in AssetEditorTools.GetAssets<EcsNetworkSettingsAsset>())
            {
                networkAsset.BakeNetworkData();
                networkAsset.MarkDirty();
            }
        }
    }


}